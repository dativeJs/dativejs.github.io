<div>
  <div id="navbar"></div>
  <div id="sidebar"></div>
  <div id="ads"></div>
  <div class="responsive-main">
<div class="pt-[60px] pb-5">
    <h1 class="text-3xl mx-3 pt-2 pb-2 font-bold" id="get-started">Getting Started</h1>
  </div>
  <div class="px-4 text-xl">
    <h1 class="text-3xl">What Is DativeJS</h1>
    <hr><br>
    <p class="dark:text-gray-200">DativeJS is a Mordern Ui JavaScript Framework</p>
    <p class="text-xl">Usage</p><br>
    <pre class="lang-shell"><code># use this to create a dative template
npx degit dativeJs/template my-app
cd my-app
npm install</code></pre>          
  <br>
  <p class="text-lg">The template scaffolded contains all the necessary dependencies needed to get started with dativejs as a Beginner</p>
  <p class="text-lg">The template scaffolded also uses <a href="https://rollup.com/" class="text-green-500">Rollup</a> to Bundle and Serve the Project Behind the Scene</p>
  <br>
<h1 class="text-3xl mx-3 pt-2 pb-2 font-bold" id="installation">Installation</h1>
<div class="text-lg px-3">
  <h1>DativeJs v2-alpha is a new approach. It's syntax is quiet different from the v2-v1.The installation is easy.There are two ways to install it.</h1>
  <ul class="px-3">
    <ul>
      <li>Cdn</li>
      <li>Npm</li>
      <li>Yarn</li>
    </ul>
  </ul>
</div>
<h1 class="px-1 text-2xl font-semibold">Cdn</h1>
<pre class="lang-html px-1"><code>&lt;!-- Development -->
&lt;script src="https://unpkg.com/dativejs@v2.0.0-alpha.1/dist/dative.js">&lt;/script>
&lt;!-- Production -->
&lt;script src="https://unpkg.com/dativejs@v2.0.0-alpha.1/dist/dative.min.js">&lt;/script>
&lt;!-- Es Module -->
&lt;script type="module">
  import Dative from 'https://unpkg.com/dativejs@v2.0.0-alpha.1?module'
  
  /* Notice the we did not do app.render()  again. In DativeJs v2-alpha the application will automatically render when there is el/target options {{'\n'}} Also notice the template: '#template' DativeJs v2-alpha can now accept id in the template the id must be from a script tag */

  
  var app = new Dative({
    el: '#app',
    data: ()=>({
      name: 'John'
    }),
    template: '#template'
  })
&lt;/script>
</code></pre>
<br><br>
<br>
</div><br>
<!-- /* Notice the we did not do   again. In DativeJs v2-alpha the application will automatically render when there is el/target options {{'\n'}} Also notice the template: '#template' DativeJs v2-alpha can now accept id in the template the id must be from a script tag */
# or the dative cli 
npm install -D create-dative-app
create-dative-app new my-app 
# or typescript 
create-dative-app new my-app --typescript 
-->
<h1 class="text-3xl mx-3 pt-2 pb-2 font-bold" id="data-and-methods">
  Data And Methods Property
</h1>
<div class="text-lg pb-4 px-4">
<h1
  id="data-property"
  class="font-bold text-2xl"
>
  Data property
</h1>
<br />
<hr />
<br />
<p>
  Data Property in Your Dative Instance is the store for your
  instance, Which Means it's what hold all the reactivity of your
  application.
</p>
<p>
  If you Coming from reactjs, data property is similar to the
  <code class="codespan">state</code> property :
</p>
<br />
<pre class="lang-jsx"><code>// reactjs
  ...

class App extends React.Component {
  ...
  state = {
    foo: 'bar'
  }
  render() {
    return (
      &lt;>
        &lt;h1>Hello {this.state.foo}&lt;/h1>
      &lt;/>
    )
  }
}</code></pre>
<br />
<p>
  If you Coming from vuejs, data property is similar to the
  <code class="codespan">data</code> property :
</p>
<br />
<pre class="lang-javascript"><code>&lt;!-- vuejs -->
&lt;template>
  &lt;h1>Hello {\{foo}}&lt;/h1>
&lt;/template>
&lt;script>
export default {
  ...,
  data: () => ({
    foo: 'bar'
  }),
  ...
}   
&lt;/script></code></pre>
<br />
<p>
  How To Write The <code class="codespan">data</code> property in Your
  dative instance
</p>
<p>
  The <code class="codespan">data</code> property can be either
  <codespan>object</codespan> or <codespan>function</codespan>
</p>
<pre class="lang-html"><code>&lt;div>
  &lt;h1>Hello {\{foo}}&lt;/h1>
&lt;/div></code></pre>
<br />
<pre class="lang-javascript"><code>import Dative from 'dativejs';

var app = new Dative({
  ...,
  data: {
    foo: 'bar'
  },
})
</code></pre>
<br />
<pre class="lang-javascript"><code>import Dative from 'dativejs';

var app = new Dative({
  ...,
  data: function() {
    return {
      foo: 'bar'
    }
  },
})
</code></pre>
<br />
<pre class="lang-javascript"><code>import Dative from 'dativejs';

var app = new Dative({
  ...,
  data: () => ({
    return {
      foo: 'bar'
    }
  }),
})
</code></pre>
<br />


<p>Quiet Easy Right, And it's same as in <i class="fab fa-vuejs text-emerald-500"></i>Vuejs </p>
<br>
<h1 class="text-3xl mx-3 pt-2 pb-2 font-bold" id="computed">Computed</h1>
        <div class="text-xl pb-4 px-4">
          <p>
            The Template Interpolation
            <code class="codespan">{\{expression}}</code>
            are very convenient, but they are meant for simple operations.
            Putting too much logic in your templates can make them bloated and
            hard to maintain. <br />
            For example:
          </p>
          <pre class="lang-javascript"><code>&lt;div>
  {\{ username.split(' ')[0].charAt(0) }}
&lt;/div></code></pre>
          <br />
          <p>
            Now the template is no longer simple and declarative. You have to
            look at it for a second before you can understand the code. The
            problem is made worse when you want to include the code in your
            template more than once.
          </p>
          <br />
          <p>
            That's why for a complex logic, You need to use a computed property
          </p>
          <h1 id="basic-example" class="font-bold">Basic Example</h1>
          <pre class="lang-html"><code>&lt;div>
  {\{ splitted }}
&lt;/div></code></pre>
          <br />
          <pre class="lang-javascript"><code>var app = new Dative({
  ...,
  data: () => ({
    username: "Tobi theAlpha"
  }),
  computed: {
    splitted: function(){
      return this.username.split(' ')[0].charAt(0)
    }
  }
})</code></pre>
          <br />
          <p>
            Here we have declared a computed property
            <code class="codespan">splitted</code>. The function we provided
            will be used as the getter function for the property
            <code class="codespan">app.splitted</code>:
          </p>
          <pre class="lang-javascript"><code>console.log(app.splitted) // => T
  app.username = 'Dev Tobi'
  console.log(app.splitted) // => D 
</code></pre>
          <br />
          <h1 id="computed-getter-and-setter" class="font-bold">
            Computed Getter and Setter
          </h1>
          <p>
            By Default, Computed are getters only, but you can also provide a
            setter when you need
          </p>
          <pre class="lang-javascript"><code>// ... 
  computed: {
    fullname: {
      get: function() {
        return this.firstName + " " + this.lastName
      }, 
      set: function(val) {
        const value = val.split(' ')
        this.firstName = value[0]
        this.lastName = value[1]
      }
    }
  }
// ... </code></pre>
          <br />
          <p>
            Now when you run
            <code class="codespan">app.fullname = 'Chuck Norris'</code>, the
            setter will be invoked and
            <code class="codespan">app.firstName</code> and
            <code class="codespan">app.lastName</code> will be updated
            accordingly
          </p>
        </div><br>
        <h1 class="text-3xl mx-3 pt-2 pb-2 font-bold" id="conditional-rendering">Conditional Rendering</h1>
          <div class="text-lg px-3">
            <h1>In DativeJs v2-alpha the <code class="codespan">dv-if</code> has been deprecated </h1>
            <h1>But You might be asking why?</h1>
            </div>
          <blockquote>
          <ul>
            <li class="text-xl">First, The <code class="codespan">dv-if</code> directive doesn't work well something</li>
            <li class="text-xl">Secondly, It doesn't have <code class="codespan">dv-else | dv-else-if</code> </li>
            </ul>
          </blockquote>
          <div class="px-3 pt-3 text-lg">
            <h1>So in DativeJs v2-alpha we introduced the<code class="codespan">{\{#if condition}}</code> Block.Which also have<code class="codespan">{\{:else if condition}}</code> and<code class="codespan">{\{:else}}</code> and  end the block with<code class="codespan">{\{/if}}</code></h1>
          </div>
<p class="text-xl px-1 font-semibold">Usage</p>
<pre class="lang-js px-1"><code>import Dative from 'dativejs';
var app = new Dative({
  el: '#app',
  data: ()=>({
    msg: 'DativeJs v2-alpha is litt',
    show: true
  }),
  template: '#template'
});</code></pre><br/>
<pre class="lang-html px-1"><code>&lt;div>
  {\{#if show}}
    &lt;h1>{\{msg}}&lt;/h1>
  {\{/if}}
&lt;/div></code></pre>
<h1 class="text-xl font-semibold">{\{:else if}}</h1>
<pre class="lang-html px-1"><code>&lt;div>
  {\{#if show}}
    &lt;h1>{\{msg}}&lt;/h1>
  {\{:else if show && !msg}}
    &lt;h1>Elseif&lt;/h1>
  {\{/if}}
&lt;/div></code></pre>
<h1 class="text-xl font-semibold">{\{:else}}</h1>
<pre class="lang-html px-1"><code>&lt;div>
  {\{#if show}}
    &lt;h1>{\{msg}}&lt;/h1>
  {\{:else if show && !msg}}
    &lt;h1>Elseif&lt;/h1>
  {\{:else}}
    &lt;h1>Else&lt;/h1>
  {\{/if}}
&lt;/div></code></pre>
  </div><br>
  <h1 class="text-3xl mx-3 pt-2 pb-2 font-bold" id="for-loop">For Loop</h1>
  <div class="text-lg px-3">
    <h1>In DativeJs v2-alpha looping in an array is more easier</h1>
  <blockquote>
  <ul>
    <p class="px-3 text-lg">Before we do something like this</p>
<pre class="lang-js py-3"><code>template: `
  &lt;div>
    ${this.data.todos.map((data)=>{
    return `&lt;h1>${data}&lt;/h1>`
    }).join("")}
  &lt;/div>
` </code></pre>
    </ul>
</blockquote>
<div class="px-3 pt-3 text-lg">
<h1>So Now in DativeJs v2-alpha we introduced the<code class="codespan">{\{#each}}</code> Block which ends the block with<code class="codespan">{\{/each}}</code></h1>
  </div>
<p class="text-xl px-3 font-semibold">Usage</p>
<pre class="lang-js px-1"><code>import Dative from 'dativejs';
var app = new Dative({
  el: '#app',
  data: ()=>({
  todos: [
    {
      id: 0,
      title: 'Working'
    },
    {
      id: 1,
      title: 'Testing'
    }
  ]
  }),
  template: '#template'
});</code></pre><br/>
<pre class="lang-html px-1"><code>&lt;div>
&lt;!--'todos' is the property and the 'todo' is the alias-->
{\{#each todos as todo}}
  &lt;h1>{\{todo.title}}&lt;/h1>
{\{/each}}
&lt;/div></code></pre>
<h1 class="px-3 text-xl font-semibold">With Index</h1>
<pre class="lang-html px-1"><code>&lt;div>
  {\{#each todos as i,todo}}
    &lt;h1>{\{i}}: {\{todo.title}}&lt;/h1>
  {\{/each}}
&lt;/div></code></pre><br />

<br />
<br />
<h1 class="text-xl font-semibold">Deconstruction</h1>
<blockquote>
<p class="text-xl px-3">The<code class="codespan">#each</code> deconstruction doesn't work well</p>
<p class="text-xl px-3">So you'll have to use the <code class="codespan">#with</code> to deconstruct</p>
</blockquote><br />
<pre class="lang-js px-1"><code>import Dative from 'dativejs';
var app = new Dative({
  el: '#app',
  data: ()=>({
  items: [
    {
      message: 'Hello world',
      rating: 6
    },
    {
      message: 'Hello mic!!',
      rating: 9
    }
  ]
  }),
  template: '#template'
});</code></pre><br />
<pre class="lang-html px-1"><code>&lt;ul>
{\{#each items as i,items}}
  {\{#with items}}
    &lt;li>{\{message}} {\{rating}}&lt;/li>
  {\{/with}}
{\{/each}}
&lt;/ul></code></pre><br />
<h1 class="px-3 text-2xl font-semibold">Looping of number</h1>
<p class="px-3 text-lg">Looping of number with the <code class="codespan">#each</code> block can not work</p><br />
<p class="px-3 text-lg">So we made a solution for that. Install dative-helper to get some cool powerful helper functions to use with Dativejs</p><br />
<p class="px-3 text-lg">The dative-helper has a <code class="codespan">$range</code> function which converts a single number into an array.<br /> You want to learn about dative-helper visit <a href="https://dativejs.js.org/helper" class="text-emerald-500">Dative-helper docs site</a></p><br />
<pre class="lang-html px-1"><code>{\{#each $range(6) as n}}
  &lt;h{\{n}}>{\{n}}&lt;/h{\{n}}>
{\{/each}}</code></pre><br />
</div><br>
<h1 class="text-3xl mx-3 pt-2 pb-2 font-bold" id="extend">Extend</h1>
          <div class="text-lg px-3">
            <h1>In DativeJs v2-alpha we've added a new Global methods <i>Dative.extend()</i></h1>
            </div>
          <blockquote>
          <ul>
            <li class="text-xl">The extend methods is used to make a component with DativeJs</li>
            </ul>
          </blockquote>
      <div>
        <h1 class="text-xl px-2">Usage</h1>
<pre class="lang-javascript px-3"><code>import Dative from 'dativejs';

// Create first Component
const Component1 = Dative.extend({
  template: `
    &lt;h1>Hello world&lt;/h1>
  `
})

// Initialize the component

var app = new Component1({
  el: 'app-component', // or an id or a class selector
})
</code></pre>   
<h1 class="text-xl px-2">Usage in html</h1>
<pre class="lang-html px-1"><code>&lt;!DOCTYPE html>
&lt;html>
  &lt;head>
    &lt;script src="/public/build/bundle.js">&lt;/script>
  &lt;/head>
  &lt;body>
    &lt;app-component>&lt;\/app-component>
  &lt;/body>
&lt;/html></code></pre><br />
 <h1 class="text-2xl">Css in Dative.extend</h1>
 <p class="text-xl">By default component css are scoped</p>
<pre class="lang-javascript px-3"><code>import Dative from 'dativejs';

// Create first Component
const Component1 = Dative.extend({
  template: `
    &lt;h1 class="big">Hello world&lt;/h1>
  `,
  css: `
    .big{
      font-size: 60px;
      color: red;
    }
  `
})</code></pre><br />
<p class="text-xl">How does the scoped css works</p>
<blockquote>
  <p class="text-xl">Dative will add a dynamic attribute with a unique key to all the child of the instance with the css options.Example</p>
</blockquote><br />
<p class="text-xl">This will be turned into</p>
<pre class="lang-html px-3"><code>&lt;h1 class="big">Hello world&lt;/h1></code></pre><br />
<pre class="lang-html px-3"><code>&lt;h1 class="big" data-dative-css="2364c-26442ag-9522">Hello world&lt;/h1></code></pre><br />
<p class="text-xl">And the css will be turned into</p>
<pre class="lang-css px-3"><code>.big{
  font-size: 60px;
  color: red;
}</code></pre><br />
<pre class="lang-css px-3"><code>.big[data-dative-css~="2364c-26442ag-9522"],[data-dative-css~="2364c-26442ag-9522"] .big {
  font-size: 60px;
  color: red;
}</code></pre><br />

<h1 class="text-xl px-3">Just like the idtotemplate converter for the Template option, The css options also have it so it means that the css can be written externally and brought to the css options with the id</h1>
<blockquote>
  <b>{{"Note".toUpperCase()}}</b>: If you are going to write the css styles externally,it should be in a style tag
</blockquote><br>
<pre class="lang-javascript px-3"><code>import Dative from 'dativejs';
 
 // Create first Component
 const Component1 = Dative.extend({
   template: `
     &lt;h1 class="big">Hello world&lt;/h1>
   `,
   css: "#css"
 })</code></pre><br />
 <p class="text-xl px-3">"text/dss" is to tell the browser that this is not css so it doesn't compile it as css.Dss stands for dative stylesheet</p><br/>
 <pre class="lang-html px-3"><code>&lt;style type="text/dss" id="css">
.big{
  font-size: 60px;
  color: red;
}&lt;/style></code></pre><br />
<blockquote>
  <b>{{"Note".toUpperCase()}}</b>: mustache also works in the css
</blockquote><br/>
<pre class="lang-javascript px-3"><code>import Dative from 'dativejs';
 
 // Create first Component
 const Component1 = Dative.extend({
   data(){
     return {
       colors: ['red','blue','green']
     }
   },
   template: `
     &lt;h1 class="big">Hello world&lt;/h1>
   `,
   css: "#css"
 })</code></pre><br />
 <pre class="lang-html px-3"><code>&lt;style type="text/dss" id="css">
.big{
  font-size: 60px;
  color: red;
}
{\{#each colors as color}}
  .bg-{\{color}} {
    background: {\{color}};
  }
  .text-{\{color}} {
    color: {\{color}};
  }
{\{/each}}
&lt;/style></code></pre><br />
<blockquote>
  <b>{{"Note".toUpperCase()}}</b>: pseudo must be after a selector.<br />
  :global() does not work in the component css
</blockquote><br/>
<h1 class="text-2xl px-2">Props</h1>
<p class="text-xl px-2">Props in Dative.extend works can be done by doing some few things.Props is always written in an object syntax with a "type" (optional)</p><br />
<pre class="lang-javascript px-3"><code>import Dative from 'dativejs';
 
 // Create first Component
 const Component1 = Dative.extend({
   template: `
     &lt;h1>Hello {\{name}}&lt;/h1>
   `,
   props:{
     name: {
       type: String
     }
   }
 })</code></pre><br />
 <p class="text-xl px-2">Or without type</p><br />
<pre class="lang-javascript px-3"><code>import Dative from 'dativejs';
 
 // Create first Component
 const Component1 = Dative.extend({
   template: `
     &lt;h1>Hello {\{name}}&lt;/h1>
   `,
   props:{
     name: String
   }
 })</code></pre><br />
 <h1 class="text-xl px-3">Using the props</h1>
 <pre class="lang-javascript px-3"><code>import Dative from 'dativejs';

var app = new Component1({
  el: 'app-component',
  props:{
    name: 'World'
  }
})</code></pre> <br><br>
<h1 class="text-3xl mx-3 pt-2 pb-2 font-bold" id="event">Event handling</h1>
          <div class="text-2xl px-3">
            <h1>Listening to Events</h1>
            </div>
<p class="text-lg px-3">We can use the <em>dv-on</em> directive to listen to DOM events and run some JavaScript when they’re triggered.</p>
<p class="text-lg px-3 font-semibold">
For example:
</p>
<pre class="lang-js px-1"><code>import Dative from 'dativejs';
var app = new Dative({
  el: '#app',
  data: ()=>({
    count: 0
  })
});</code></pre><br/>
<pre class="lang-html px-1"><code>&lt;div>
  &lt;h1>{\{count}}&lt;/h1>
  &lt;button dv-on:click="count+=1">Increment&lt;/button>
&lt;/div></code></pre>
<h1 class="px-3 text-xl font-semibold">Using the methods options</h1>
<br />
<pre class="lang-js px-1"><code>import Dative from 'dativejs';
var app = new Dative({
  el: '#app',
  data: ()=>({
    count: 0
  }),
  methods:{
    add(){
      this.count++
    }
  },
});</code></pre>
<pre class="lang-html px-1"><code>&lt;div>
  &lt;h1>{\{count}}&lt;/h1>
  &lt;button dv-on:click="add()">Increment&lt;/button>
&lt;/div></code></pre><br><br>
 <h1 class="text-3xl mx-3 pt-2 pb-2 font-bold" id="property">Property DativeJs</h1>
    <div class="text-lg pb-4 px-4">
    <p>
            The <code class="codespan">defineProperty</code> is an alias of the
            <code class="codespan">Dative.prototype</code>
          </p>
          <p>
            That means the <code class="codespan">defineProperty</code> is used
            to make global property.
          </p>
          <br />
          <h1 class="font-bold" id="what-is-a-property">What Is a Property</h1>
          <hr />
          <br />
          <p>
            A Property in Dative is Just like the data property but the property
            is prefixed with a <code class="codespan">$</code> at the beginning
            of the property
          </p>
          <p>
            Dative v2-alpha now provide a new option and global method for
            defining a property
          </p>
          <br />
          <li>Global (Constructor) method</li>
          <br />
          <pre
            class="lang-typescript"
          ><code>defineProperty(name: string, callback: ()=> any): void</code></pre>
          <br />
          <pre class="lang-javascript"><code>import { defineProperty } from 'dativejs';
defineProperty('foo', function(){ 
  return 'bar'
})</code></pre>
          <br />
          <li>Options</li>
          <br />
          <pre class="lang-typescript"><code>interface property {
  [x:string]: Function
}</code></pre>
          <br />
          <pre class="lang-javascript"><code>import Dative from 'dativejs';
new Dative({
  ...,
  property: {
    foo: function() {
      return 'bar'
    }
  }
})</code></pre>
          <br />
          <h1 id="why-two-ways-of-defining-property">
            Why Two Ways of defining Property?
          </h1>
          <p>
            The Reason of the having two ways is that one is accessable
            everywhere (globally) in Your application and the other one is
            scoped to only a particular instance
          </p>
          <h1 class="font-bold" id="question">Question</h1>
          <li class="underline text-emerald-500 decoration-emerald-600">Which of one is Global and which Scoped ?</li>
          <h1 class="font-bold" id="answer">Answer</h1>
          <p>1. Global method is global (already mentioned by the name)</p>
          <p>2. Options is Scoped to the instance it's created in</p> 
          <br>
          <h1 class="font-bold" id="how-to-access-the-property-in-the-template">How to Access the Property in the template</h1><br>
          <hr>
          <br>
          <pre class="lang-html"><code>&lt;div>
  &lt;h1>{\{$foo}}&lt;/h1>
&lt;/div></code></pre></div><br><br>
<h1 class="text-3xl mx-3 pt-2 pb-2 font-bold" id="plugin">Plugin DativeJs</h1>
        <div class="text-lg pb-4 px-4">
          <h1 class="text-xl">Dative v2-alpha plugin are quiet similar</h1>
          <p>But the difference is the way of appying it</p>
          <p>The Global Function</p>
          <br />
          <pre
            class="lang-typescript"
          ><code>Dative.use(plugin: DativePlugin): { install(Dative: Dative) }</code></pre>
          <br />
          <p>The Function Has Been deprecated</p>
          <p>So we added a new option and instance method</p>
          <p class="underline">1. Option</p>
          <br />
          <pre class="lang-typescript"><code>new Dative({
  ...,  
  use: [function({ instance, proto, Dative }: { instance: this, proto: Dative.prototype, Dative: Dative }){
    ...
  }]
})</code></pre>
          <p class="underline">2. Instance Method</p>
          <br />
          <pre class="lang-typescript"><code>var app = new Dative({...})
app.use(function({ instance, proto, Dative }: { instance: this, proto: Dative.prototype, Dative: Dative }){
  ...
})</code></pre>
          <br />
          <h1 class="font-semibold" id="whats-a-plugin-used-for">
            What's Plugin Used For
          </h1>
          <br />
          <hr />
          <br />
          <p class="text-lg">
            Plugins usually add global-level functionality to Dative. There is
            no strictly defined scoped for a plugin - there are typically
            several types of plugins you can write:
          </p>
          <li class="text-lg">
            Add some global methods or properties. eg -
            <a href="https://dativejs.js.org/helper" class="text-green-400"
              >@dativejs/helpers</a
            >
          </li>
          <p class="text-lg">
            A Dative.js plugin can expose an
            <code class="codespan">install</code>
            method or without. The method will be called with a deconstructed
            params with three options,
            <code class="codespan">{ instance, proto, Dative }</code>
          </p>
          <pre
            class="lang-javascript"
          ><code>var MyPlugin = function({ instance, proto, Dative }){
// Dative=> the Dative constructor
// instance=> the current instance of your application
// proto=> the Dative prototype

// 1. Let's make a global property
Dative.defineProperty('appName',function(){
  return 'Dative News'
})
}</code></pre>
          <br />
          <h1 class="font-semibold" id="using-a-plugin">Using a Plugin</h1>
          <p class="underline">1. Option</p>
          <br />
          <pre class="lang-javascript"><code>new Dative({
  ...,  
  use: [MyPlugin]
})</code></pre>
          <p class="underline">2. Instance Method</p>
          <br />
          <pre class="lang-javascript"><code>var app = new Dative({...})
app.use(MyPlugin)
 </code></pre>
          <br />
          <h1 class="font-bold hover:underline" id="question">Question</h1>
          <p>
            You may ask question like "Why is there two ways for using plugins"?
          </p>
          <h1 class="font-bold hover:underline" id="answer">Answer</h1>
          <p>
            First, Dative templates are scoped and not exposed before mounted,
            So for developer's making plugins that are to access the template,
            the developers are to use the instance method access it
          </p>
          <br />
          <p>
            Second, Variaty which means a developer may like the options way and
            hate the instance method way and others may be vice-versa
          </p>
          <br><br>
          <h1 class="text-2xl px-2" id="creating-a-plugin">Creating A Plugin for Global Usuage</h1>
          <p class="text-xl">File Structure</p><br>
          <pre class="language-treeview"><code> - my-plugin
 -- dist 
   -- my-plugin.esm.js // Es Module
   -- my-plugin.cjs.js // Common Js
   -- my-plugin.js // iife 
 -- src 
   -- index.js 
 -- test 
   --index.test.js
 -- index.mjs // Es Module
 -- index.js // Common js
 -- types // not compulsory (for typings)
 -- rollup.config.js // bundler file
 -- readme.md
 --package.json
</code></pre><br>
<p class="text-xl">package.json</p><br>
<blockquote>
  <b>{{"Note".toUpperCase()}}</b><br>
  <p>Your plugin name must be prefixed with <codespan>@dativejs</codespan>. Example</p>
  <p>
    <codespan>@dativejs/my-plugin</codespan>
  </p>
</blockquote><br>

<pre class="language-json"><code>{
  "name": "@dativejs/&lt;your-plugin-name>",
  "version": "1.0.0",
  "description": "&lt;your-plugin-description>",
  "main": "dist/&lt;your-plugin-name>.cjs.js",
  "module": "dist/&lt;your-plugin-name>.esm.js",
  "types": "src/&lt;your-plugin-name>.d.ts",
  "unpkg": "dist/&lt;your-plugin-name>.js",
  "jsdelivr": "dist/&lt;your-plugin-name>.js",
  "files": [
    "index.js",
    "index.mjs",
    "dist",
    "types",
    "rollup.config.js",
    "src",
    "readme.md"
  ],
  "scripts": {
    "build": "rollup -c"
  },
  "exports": {
    ".": {
      "import": {
        "node": "./index.mjs",
        "default": "./dist/&lt;your-plugin-name>.esm.js"
      },
      "require": "./index.js"
    },
    "./package.json": "./package.json"
  },
  "buildOptions": {
    "name": "&lt;your-plugin-name>",
    "formats": [
      "esm-bundler",
      "cjs",
      "global"
    ]
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/&lt;yourusername>/&lt;your-plugin-name>.git"
  },
  "keywords": [
    "&lt;your-plugin-name>",
    "Dativejs"
  ],
  "author": "Your Name",
  "license": "&lt;Your License>",
  "bugs": {
    "url": "https://github.com/&lt;yourusername>/&lt;your-plugin-name>/issues"
  },
  "homepage": "&lt;YOUR_HOMEPAGE>"
}</code></pre><br>
<!-- <p class="text-xl">You can run this command in your terminal to scaffold a plugin folder</p><br>
<p class="text-xl">Install The DativeJs Cli if you've not installed it</p><br> 
<pre class="lang-shell"><code>npm install -D create-dative-app</code></pre><br>
<pre class="lang-shell"><code>create-dative-app generate plugin &lt;your-plugin-name></code></pre><br><br>
<p class="text-xl">This command will create a folder structure for creating the dative plugin</p>  <br>     -->

<blockquote>
  <b>{{"Note".toUpperCase()}}</b><br>
  <p>Your plugin Should be Upload To dative plugins github repo </p>
  <p>
   <a href="https://madedwithdativejs.js.org/upload">Click Here</a>
  </p>
</blockquote><br>

<br>
<h1 class="text-2xl">Official Plugins For DativeJs</h1>
          <p>
            <a href="https://madedwithdativejs.js.org/plugins/" class="text-emerald-400"
              ><span>Click Here</span></a
            >
          </p>
        </div>
        <br>
        <br>
          <h1 class="text-3xl mx-3 pt-2 pb-2 font-bold" id="debug">Debug</h1>
        <div class="text-lg px-3 pb-3">
          <p>
            The debug expression is uses to log a code in the browser and the
            special thing it does is that it adds a
            <codespan>debugger</codespan>
            keyword to it
          </p>
          <br />
          <pre class="lang-html"><code>{\{@debug variable}}</code></pre>
          <br />
          <blockquote>
            <p>
              <b>Note</b>: the <codespan>debug</codespan> accepts object
              property only. <br />
              That means <codespan>string</codespan>,
              <codespan>arrays</codespan>,<codespan>function</codespan> will not
              work
            </p>
          </blockquote><br>
          <pre class="lang-html"><code>{\{@debug 'hi'}}
{\{@debug ['hu']}}
{\{@debug ()=> 'hi'}}
// all these will not work</code></pre><br />
            <p class="text-xl">The debug expression also accepts multiple params seperated by a comma</p><br>
          <pre class="lang-html"><code>{\{@debug variable1,variable2,variable3}}</code></pre>
          <br />
        </div>
          <h1 class="text-3xl mx-3 pt-2 pb-2 font-bold" id="with">With block</h1>
        <div class="text-lg px-3 pb-3">
          <h1>The <b>with block</b> extends the scope chain for a statement</h1>
          <br />
          <h1>
            The <b>With block</b> is same as the <b>with statement</b> in
            javascript
          </h1>

          <h1 class="text-2xl">Syntax</h1>
          <br />
          <pre class="lang-javascript"><code>{\{#with expression}}
  statement
{\{/with}}</code></pre>
          <br /><br />
          <h1>In Vanilla Javascript</h1>
          <pre class="lang-javascript"><code>with (expression){
   statement
}</code></pre>
          <br />
          <hr />
          <br />
          <h1 class="text-xl">
            What is the <codespan>with</codespan> block used for?
          </h1>
          <br /><br />
          <p>
            The <codespan>with</codespan> block is used just like the
            <codespan>with</codespan> statement in javascript. <br />
            It adds the given object to the head of this scope chain during the
            evaluation of it's body. If an unqualified name used in the body
            matches a property in the scope chain, then the name is bound to the
            property and the object containing the property. Otherwise a
            <span
              class="decoration-sky-700"
            >
              ReferenceError
          </span>
            is thrown
          </p>
          <br /><br />
          <h1 class="text-2xl font-bold">Example</h1>
          <p>
            The following <codespan>with</codespan> block specifies that the
            Math object is the default object. <br />
            The blocks following the <codespan>with</codespan> block refer to
            the PI property and other Math Property and methods, without
            specifying an object.
          </p><br><br>
          <pre class="lang-jsx"><code>{\{$: r = 10;}}
{\{#with Math}}
    &lt;h1>{\{PI * r * r}}&lt;/h1>          
    &lt;h1>{\{PI * cos(PI)}}&lt;/h1>          
    &lt;h1>{\{PI * sin(r * r)}}&lt;/h1>          
{\{/with}}</code></pre>
          <br />
        </div><br><br>
        <h1 class="text-3xl mx-3 pt-2 pb-2 font-bold" id="directives">Directives</h1>
          <div class="text-2xl px-3">
            <h1 id="event">Event Directives</h1>
          </div>
          <br />
          <pre class="lang-js px-1"><code>import Dative from 'dativejs';
var app = new Dative({
  el: '#app',
  data: ()=>({
    count: 0
  }),
  template: '#template'
});</code></pre>
          <br />
          <pre class="lang-html px-1"><code>&lt;div>
  &lt;h1>{\{count}}&lt;/h1>
  &lt;button dv-on:click="count+=1">Increment&lt;/button> 
&lt;/div></code></pre>
          <br />
          <h1 class="px-3 text-xl font-semibold">Using the methods options</h1>
          <br />
          <pre class="lang-js px-1"><code>import Dative from 'dativejs';
var app = new Dative({
  el: '#app',
  data: ()=>({
    count: 0
  }),
  methods:{
    add(){
      this.count++
    }
  },
  template: '#template'
});</code></pre>
          <br />
          <pre class="lang-html px-1"><code>&lt;div>
  &lt;h1>{\{count}}&lt;/h1>
  &lt;button dv-on:click="add()">Increment&lt;/button>
&lt;/div></code></pre>
          <br />
          <p class="text-xl">
            <codespan>on:&lt;event></codespan> is a short form for
            <codespan>dv-on:&lt;event></codespan>
          </p>
          <br />
          <div class="text-2xl px-3">
            <h1>Animate Directives</h1>
          </div>
          <br />
          <pre class="lang-html px-1"><code>&lt;div>
  &lt;h1 animate:bounce="1000,50">Bounce&lt;/h1>
&lt;/div></code></pre>
          <br />
          <blockquote>
            <p class="text-xl">
              <b>Note</b>: The animate directives is on experimental mode, So it
              doesn't work that well
            </p>
          </blockquote><br>
          <a href="#animate" class="text-emerald-500"
            >Learn More About Animate Directive</a
          >     
        <h1 class="text-3xl mx-3 pt-2 pb-2 font-bold" id="define-api">Define Api</h1>
        <div class="text-xl px-3 pb-3">
          <p>
            The <b>define</b> api is a new way to create a dative instance and
            also a shorter way
          </p>
          <p>The <b>define</b> api has two methods:</p>
          <div>
            <li>defineApp</li>
            <li>defineProperty</li>
          </div>
          <p>The first  methods is to create the dative instance</p>
          <p><b>Example:</b></p>
          <p>With the new function <b>defineApp</b></p>
          <br />
          <pre
            class="lang-javascript"
          ><code>function defineApp(options: any): Dative</code></pre>
          <br />
          <p>You don't need to call the <b>new</b> keyword</p>
          <pre class="lang-javascript"><code>import { defineApp } from 'dativejs';

var app = defineApp({
    el: "#app",
    template: ""
})</code></pre>
          <br />
          <br />
        </div><br><br>
         <h1 class="text-3xl mx-3 pt-2 pb-2 font-bold" id="comment">
            Commenting
          </h1>
        <div class="text-lg pb-4 px-4">
          <p>DativeJS v2-alpha has a new way for commenting now</p>
          <p>There are two ways:</p>
          <ul class="list-disc px-3">
            <li>Html Comment</li>
            <li>Dative Comment</li>
          </ul>
          <br />
          <h1 class="text-2xl underline">1. Html Comment</h1>
          <p>
            The Html Comment is the normal comment you use everyday with html.
            That's the:
          </p>
          <br />
          <pre class="lang-html"><code>&lt;!-- this is  html comment --></code></pre>
          <br />
          <p>
            The Html Comment is been rendered to the Dom and dative sees it as a
            normal tag. That's the dative interpolation's will be parsed in the
            html comment and will give error if it finds a variable thats not
            registered in the dative instance
          </p>
          <br />
          <h1 class="text-2xl underline">2. Dative Comment</h1>
          <p>
            The Dative Comment is quiet different from the normal comment,but if
            you coming from hbs(handlebars/mustache) You Can Understand the
            dative comment. That's the:
          </p>
          <br />
          <pre class="lang-html"><code>{\{!this is  dative comment}}</code></pre>
          <br />
          <p>
            The Dative Comment is not been rendered to the Dom and dative doesn't sees it as a
            normal tag but as a comment. That's the dative interpolation's will not be parsed in the
            html comment and will not give error if it finds a variable thats not
            registered in the dative instance
          </p>
        </div><br><br>
        <h1 class="text-3xl mx-3 pt-2 pb-2 font-bold" id="variable">Variable</h1>
        <div class="text-lg px-3 pb-3">
          <p>
            Variable in Dativejs uses the js label syntax
            <codespan>$:</codespan> similar to sveltejs
          </p>
          <pre class="lang-javascript"><code>&lt;!-- svelte -->
&lt;script> 
   $: app = 'yes'
&lt;/script>

&lt;h1>{app}&lt;/h1></code></pre>
          <br />
          <p>
            The variable in dativejs is quiet the same with sveltejs but the
            different in it is that dativejs variable are in-between the
            expression <codespan>{\{ expression }}</codespan>
          </p>
          <br />
          <pre
            class="lang-html"
          ><code>{\{$: foo = ()=> 'bar';}} {\{! as a function }}
{\{$: foo = 'bar';}} {\{! as a string}}
{\{!literally the variable can accept anything the normal js variable can accept}}</code></pre>
          <br />
          <h1 class="text-2xl">What is the variable Used for?</h1>
          <p>
            The Variable is used to store local properties inside your template
            only without having to the the template file. <br />
            It works like the computed property.
          </p>
          <blockquote>
            <p>
              <b class="capitalize">Note</b>: The variable block uses <codespan>let</codespan> under the hood
            </p>
          </blockquote>
          <a href="#computed" class="text-emerald-500"
            >Learn More About Computed Property</a
          ><br />
          <h1 class="text-2xl">Example</h1>
          <br />
          <hr />
          <br>
          <pre class="lang-jsx rounded"><code>{\{$: names = ['Foo','Bar'];}}
&lt;div> 
  &lt;ul> 
    {\{#each names as name}}
      &lt;li>{\{name}}&lt;/li>
    {\{/each}}
  &lt;/ul>
&lt;/div></code></pre>
          <br />
          <blockquote>
            <b>Note</b>: Do Not Use This in an application that requires
            reactivity because it's not reactive.
          </blockquote>
          <br />
        </div><br>
        <div class="text-lg px-3 pb-3">
          <h1 class="text-2xl font-bold pb-2" id="animation">Animation</h1>
          <p>We've Introduced the <codespan>animate</codespan> options has been introduced in dativejs</p>
          <h1 id="whats-the-animate-option">What is the Animate options used For ??</h1>
          <p>
            The <codespan>animate</codespan> Options is Used To Define Animation in DativeJs. 
            <br>
            Then You Might Be Like.
            <b>How Can I Use It</b>
          </p>
          <blockquote>
            <p><b>{{"Note".toUpperCase()}}</b>: DativeJs animate Api Uses the Web Animation Api</p>
          </blockquote>
          <p class="text-2xl">Usage:</p>
          <pre class="lang-ts"><code>import {defineApp} from 'dativejs';
    
  var app = defineApp({
    el: '#app',
    template: `
      &lt;div>
        &lt;h1>Hola!!&lt;/h1>
      &lt;/div>
    `,
    animate: {
      flash: function({animate,duration,delay}) {
        animate([
          {
            opacity: 1
          },
          {
            opacity: 0
          },
        ],{
          duration,
          delay,
          easing: "linear",
        })
      }
    }
  })</code></pre>
<br>
<p class="text-2xl">Using in the template</p>
<br>
<pre class="lang-ts"><code>...,
template:`
&lt;div>
   &lt;h1 animate:flash="3000,50">Hola!!&lt;/h1>
&lt;/div>
`</code></pre>
<br>
<h1 id="how-to-understand-the-animate-directives" class="text-2xl">How to Understand the Animate Directives</h1><br>
<pre class="lang-html"><code>&lt;h1 animate:flash="&lt;duration>,&lt;delay>">Hola!!&lt;/h1></code></pre><br>
<pre class="lang-ts"><code>import {defineApp} from 'dativejs';
    
  var app = defineApp({
    el: '#app',
    template: `
      &lt;div>
        &lt;h1>Hola!!&lt;/h1>
      &lt;/div>
    `,
    animate: {
      flash: function({animate,duration,delay}) {
        // animate is an alias to the current element.animate 
        // duration comes from the directive
        // delay also comes from the directive
      }
    }
  })</code></pre>
<p class="text-xl">Short Way Form For the Animate directives is <codespan>@&lt;animation-name></codespan></p>

<p class="text-xl">The parameter in each animation receive 4 options</p>
<br>
<pre class="lang-ts"><code>type Animate = {
   animate: (keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions)=> Animation,
   duration: number,
   delay: number,
   setStyle: (options: CSSStyleDeclaration)=> void
}

type DativeAnimateOptions = {
  [x:string]: function({ animate,duration,delay, setStyle }: Animate) => void
}</code></pre>
<p>
  DativeJS Animation Api Doesn't have much Animations So We Introduced <codespan>@dativejs/animation</codespan>
  For More Information <a href="https://dativejs.js.org/animations" class="text-emerald-600">Click here</a>
</p>
    </div>
      <br>
    </div>
    <p class="text-white text-xl ">
      Last Modified: {{transformer(Date.now())}}
    </p>
  </div>
  <div id="footer" class="relative"></div>
</div>
  </div>